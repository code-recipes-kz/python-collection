"""
Создаем список queue_lengths длиной n (количеством касс), и заполняем его нулями. Этот список будет хранить текущую длину очереди для каждой кассы. Например, для n = 2, список queue_lengths будет выглядеть так: [0, 0].

Проходим по каждому клиенту в очереди customers с помощью цикла for и переменной time, которая будет содержать время обслуживания текущего клиента.

Находим индекс кассы с наименьшей длиной очереди из списка queue_lengths с помощью метода index() и функции min(). Это будет индекс кассы, к которой текущий клиент будет направлен.

Добавляем время обслуживания текущего клиента (time) к длине очереди выбранной кассы (queue_lengths[min_queue_index]), обновляя значение в списке queue_lengths.

Повторяем шаги 3-4 для каждого клиента в очереди, чтобы распределить их по кассам в соответствии с текущим состоянием очередей.

После обработки всех клиентов, возвращаем максимальное значение в списке queue_lengths с помощью функции max(). Это значение будет равно общему времени, необходимому для обслуживания всех клиентов, так как оно соответствует длине самой длинной очереди после обслуживания всех клиентов.
"""

# tags: Arrays, Fundamentals
# kyu: 6

def queue_time(customers, n):
    # Создаем список с длинами очередей для каждой кассы, изначально заполняем нулями
    queue_lengths = [0] * n
    # Проходим по каждому клиенту в очереди
    for time in customers:
        # Находим кассу с наименьшей длиной очереди и добавляем время обслуживания текущего клиента к этой длине
        min_queue_index = queue_lengths.index(min(queue_lengths))
        queue_lengths[min_queue_index] += time
    # Возвращаем максимальное значение в списке длин очередей, которое будет равно общему времени обслуживания всех клиентов
    return max(queue_lengths)