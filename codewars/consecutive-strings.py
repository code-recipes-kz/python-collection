"""
При вызове функции longest_consec с массивом строк strarr и целым числом k, она возвращает первую самую длинную строку, состоящую из k последовательных строк из массива strarr. Если strarr пустой, k больше, чем длина strarr или k меньше или равно 0, функция возвращает пустую строку "".

Функция принимает два аргумента: strarr, который является входным массивом строк, и k, который является числом последовательных строк, которые нужно объединить.
Функция проверяет, что массив strarr не пустой, и что k не превышает длину strarr и не меньше или равен 0. Если это условие не выполняется, функция возвращает пустую строку "".
Если условие из пункта 2 выполняется, функция создает переменную longest_string и инициализирует ее пустой строкой. Эта переменная будет содержать самую длинную строку, найденную в массиве strarr.
Далее, функция перебирает индексы от 0 до n - k, где n - это длина массива strarr. Это делается с помощью цикла for и функции range, чтобы получить все возможные комбинации последовательных строк, состоящих из k элементов.
Внутри цикла, функция использует срезы массива strarr для получения подмассива, состоящего из k последовательных элементов, начиная с текущего индекса i. Затем, эти строки объединяются в одну строку с помощью метода join и сохраняются в переменной consec_string.
Далее, функция сравнивает длину строки consec_string с длиной строки longest_string. Если consec_string длиннее, то longest_string обновляется и принимает значение consec_string.
После окончания цикла, longest_string содержит самую длинную строку, состоящую из k последовательных строк в массиве strarr.
Функция возвращает значение longest_string, которое является ответом на задачу. Если не было найдено ни одной последовательности строк длиннее 0, функция вернет пустую строку "".
"""

# tags: Fundamentals
# kyu: 6

def longest_consec(strarr, k):
    n = len(strarr)
    if n == 0 or k > n or k <= 0:
        return ""
    else:
        longest_string = ""
        for i in range(n - k + 1):
            consec_string = "".join(strarr[i:i + k])
            if len(consec_string) > len(longest_string):
                longest_string = consec_string
        return longest_string