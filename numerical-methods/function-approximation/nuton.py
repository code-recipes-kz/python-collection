# Код, который я написал, решает задачу интерполяции функции с помощью интерполяционного полинома Ньютона.
# Вот пошаговое объяснение того, как он работает:
# Определяются входные данные для задачи интерполяции: x_values, y_values и x. x_values и
# y_values являются списками точек, через которые нужно провести интерполяционный полином. x - это точка, для которой
# нужно вычислить значение интерполяционного полинома.
# Определяется длина списка x_values, который будет использоваться для определения
# количества разделенных разностей, которые нужно вычислить, чтобы построить интерполяционный полином.
# Создается двумерный массив f, который будет использоваться для хранения разделенных разностей.
# Этот массив инициализируется значениями из списка y_values. В первом столбце этого массива находятся значения функции f(x_i) = y_i.
# Вычисляются оставшиеся разделенные разности в массиве f. Для вычисления каждого элемента массива
# используются значения из предыдущего столбца и значения из соответствующих строк массива. Таким образом, элемент
# f[i][j] вычисляется как (f[i+1][j-1] - f[i][j-1]) / (x_values[i+j] - x_values[i]).
# Выводится таблица конечных разностей в формате, который позволяет увидеть все значения массива f. В таблице
# конечных разностей в первом столбце находятся значения функции f(x_i) = y_i, а в каждом следующем столбце находятся разделенные разности.
# Вычисляется значение интерполяционного полинома. Для этого сначала вычисляются все
# произведения вида (x - x_values[j]), где j изменяется от 0 до i-1. Затем вычисляется сумма всех таких произведений,
# умноженных на соответствующие коэффициенты f[0][i].
# Возвращается значение интерполяционного полинома для заданной точки x.
# Таким образом, этот код решает задачу интерполяции функции с помощью интерполяционного полинома Ньютона,
# используя метод конечных разностей. Он вычисляет таблицу конечных разностей и использует ее для построения интерполяционного полинома.


def newton_interpolation(x_values, y_values, x):
    """
    :param x_values: список значений x
    :param y_values: список значений y
    :param x: значение, для которого нужно найти приближенное значение y
    :return: приближенное значение y, рассчитанное с помощью интерполяционного полинома Ньютона
    """
    n = len(x_values)
    # Инициализация разделенных разностей
    f = [[None] * n for _ in range(n)]
    for i in range(n):
        f[i][0] = y_values[i]
    # Вычисление разделенных разностей
    for j in range(1, n):
        for i in range(n - j):
            f[i][j] = (f[i+1][j-1] - f[i][j-1]) / (x_values[i+j] - x_values[i])
    # Вывод таблицы конечных разностей
    print("Таблица конечных разностей:")
    for row in f:
        for elem in row:
            if elem is not None:
                print("{:.4f}".format(elem), end="\t")
            else:
                print("\t", end="")
        print()
    # Вычисление значения интерполяционного полинома
    y = 0
    for i in range(n):
        prod = f[0][i]
        for j in range(i):
            prod *= (x - x_values[j])
        y += prod
    return y

x_values = [1, 2, 3]
y_values = [2, 7, 11]
x = 1
y = newton_interpolation(x_values, y_values, x)
print("Значение интерполяционного полинома в точке x = {:.2f}: {:.4f}".format(x, y))
