# https://math.semestr.ru/optim/zeidel.php

# Этот код реализует метод Зейделя для решения системы линейных уравнений Ax = b, где A - матрица коэффициентов размерности n x n, b - вектор свободных членов размерности n и eps - заданная точность.

# 1. Импортируются необходимые библиотеки: модуль math для извлечения квадратного корня и библиотека NumPy для работы с массивами.
# 2. Определяется функция seidel, которая принимает на вход три аргумента: матрицу коэффициентов A, вектор свободных членов b и точность eps.
# 3. Получается размерность матрицы A с помощью функции len.
# 4. Создается массив x из нулей размерности n. Это массив, который будет содержать начальное приближение для решения системы.
# 5. Устанавливается флаг converge равный False, который указывает на то, что решение еще не сошлось.
# 6. Начинается итерационный процесс с помощью цикла while. Этот цикл продолжается до тех пор, пока решение не станет достаточно близким к истинному с заданной точностью eps.
# Создается копия массива x с помощью функции np.copy, которая позволяет изменять копию массива, не затрагивая оригинал.
# Начинается внутренний цикл for, который проходит по всем строкам матрицы A.
# Для каждой строки i вычисляется сумма s1, содержащая произведения A[i][j] * x_new[j] для всех j от 0 до i-1.
# Вычисляется сумма s2, содержащая произведения A[i][j] * x[j] для всех j от i+1 до n-1.
# Вычисляется новое значение x_new[i] с использованием формулы метода Зейделя.
# Проверяется, сошлось ли решение с заданной точностью eps с помощью вычисления квадратного корня из суммы квадратов разностей между соответствующими элементами массивов x_new и x.
# Если решение сошлось, флаг converge устанавливается в True и цикл while завершается.
# Если решение не сошлось, массив x обновляется новым значением x_new.
# После завершения итерационного процесса, функция seidel возвращает массив x, содержащий найденное решение системы линейных уравнений.

from math import sqrt
import numpy as np

def seidel(A, b, eps):
    n = len(A)
    x = [.0 for i in range(n)]

    converge = False
    while not converge:
        x_new = np.copy(x)
        for i in range(n):
            s1 = sum(A[i][j] * x_new[j] for j in range(i))
            s2 = sum(A[i][j] * x[j] for j in range(i + 1, n))
            x_new[i] = (b[i] - s1 - s2) / A[i][i]

        converge = np.max(np.abs(x_new - x)) <= eps
        x = x_new

    return x

A = np.array([[10, 1, 1], [2, 10, 2], [1, 1, 10]])
b = np.array([12, 14, 10])
x = np.array(0)

x = seidel(A, b, x)
print(x)